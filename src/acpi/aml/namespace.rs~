use collections::string::String;
use collections::vec::Vec;
use collections::boxed::Box;

#[derive(Debug)]
pub struct AmlNamespace {
    name: String,
    contents: AmlNamespaceContents
}

#[derive(Debug)]
pub enum AmlNamespaceContents {
    Value(AmlValue),
    SubNamespace(Box<AmlNamespace>),
    Namespace(Vec<AmlNamespaceContents>)
}
    
#[derive(Debug)]
pub enum AmlValue {
    Uninitialized,
    Buffer,
    BufferField,
    DDBHandle,
    DebugObject,
    Device,
    Event,
    FieldUnit,
    Integer,
    IntegerConstant,
    Method,
    Mutex,
    ObjectReference,
    OperationRegion,
    Package,
    String,
    PowerResource,
    Processor,
    RawDataBuffer,
    ThermalZone
}

impl AmlNamespace {
    fn push(&mut self, val: Box<AmlScopeVal>) {
        self.contents.push(val);
    }

    fn push_subordinate_namespace(&mut self, scope_string: String) {
        if scope_string.len() == 0 {
            return;
        }
        
        let mut scope_string = scope_string.clone();
        
        if scope_string.starts_with("\\") {
            if self.name != "\\" {
                return;
                // Absolute path from the namespace root, and we're not at the root. Something went badly wrong if we get here. Consider panicking
            }

            scope_string.remove(0);
        }

        let (current, nextset) = match scope_string.find(".") {
            Some(s) => {
                let (x, mut y) = scope_string.split_at(s);
                y = &y[1..];

                (String::from_str(x).unwrap(), String::from_str(y).unwrap())
            },
            None => if scope_string.len() <= 4 {
                (scope_string, String::from_str("").unwrap())
            } else {
                return;
            }
        };

        for c in self.contents {
            match c {
                AmlTables { name: name, contents: contents } => if name == current {
                    c.push_subordinate_namespace(nextset);
                    return;
                },
                _ => ()
            }
        }

        let mut next = AmlTables { name: current, contents: vec!() };
        next.push_subordinate_namespace(nextset);

        self.push(Box::new(next));
    }
}
